=================
Class-based views
=================

A view is a callable which takes a request and returns a
response. This can be more than just a function, and Django provides
an example of some classes which can be used as views. These allow you
to structure your views and reuse code by harnessing inheritance and
mixins. There are also some generic views for simple tasks which we'll
get to later, but you may want to design your own structure of
reusable views which suits your use case. For full details, see the
:doc:`class-based views reference documentation</ref/class-based-views/index>`.

.. toctree::
   :maxdepth: 1

   intro
   generic-display
   generic-editing
   mixins
   usage-patterns

Why class-based views?
======================

At their core, class-based views are intended to solve the same problem as
function-based views: process requests and return responses. What makes class
views different from function views is the approach they provide to solving
that problem.

That approach, as you could guess by the name, is modularity and extensibility
via Python classes. The cost is potentially lost clarity around a view's flow
of control. However, there are situations where for a sufficiently complex view
the flow of control can be unclear and the implied flow-control offered by
a well documented base-class becomes appropriate. These are differences 
demonstrated with
:doc:`usage patterns</topics/class-based-views/usage-patterns>`.

Why so many methods with this approach?
=======================================

You might notice with class-based views that once you break from a convention
prescribed by a base-class, there are a lot of potential hook methods you could
extend to achieve your goal. In short, this is because the approach with many
of the provided base-classes and mixins is to define workflow using the classic
`template method <http://en.wikipedia.org/wiki/Template_method_pattern>`_
design pattern. The benefit here is that there are some straightforward
high-level methods that do easy-to-understand things, like
:meth:`~django.views.generic.base.TemplateResponseMixin.render_to_response()`.
Then there are specialized methods that let you hook into that "template method"
such as
:meth:`~django.views.generic.detail.SingleObjectMixin.get_context_data()`
(which is a more commonly extended method).

When should I use class-based views?
====================================

The :doc:`usage patterns</topics/class-based-views/usage-patterns>` should help
you draw a useful comparison, but here are some questions that may help guide
you:

#. Is your view supported by a generic view?
#. Do you have a function-based view that is greater than 20-30 lines of code?
#. Do you have a generic view that needs to be extended or configured?
#. Is it hard to test specific logic within your view function?
#. Have decorators increased the minimum overhead required to test your view
   function.

So, when should you choose class-based views? Whenever the complexity of your
view warrants modularity or re-usability similar to the generic views
(:doc:`display</topics/class-based-views/generic-display>` and
:doc:`editing</topics/class-based-views/generic-editing>`) or these
:doc:`usage patterns</topics/class-based-views/usage-patterns>`. If you're
having trouble determining what's right, please peruse those pages to see if
your case looks similar and inform your decision.

Finally, while the class-based generic views do provide good examples and
anc comparisons for designing views, they are not required to be the basis of
your views.


Basic examples
==============

Django provides base view classes which will suit a wide range of applications.
All views inherit from the :class:`~django.views.generic.base.View` class, which
handles linking the view in to the URLs, HTTP method dispatching and other
simple features. :class:`~django.views.generic.base.RedirectView` is for a
simple HTTP redirect, and :class:`~django.views.generic.base.TemplateView`
extends the base class to make it also render a template.


Simple usage in your URLconf
============================

The simplest way to use generic views is to create them directly in your
URLconf. If you're only changing a few simple attributes on a class-based view,
you can simply pass them into the
:meth:`~django.views.generic.base.View.as_view` method call itself::

    from django.conf.urls import url
    from django.views.generic import TemplateView

    urlpatterns = [
        url(r'^about/$', TemplateView.as_view(template_name="about.html")),
    ]

Any arguments passed to :meth:`~django.views.generic.base.View.as_view` will
override attributes set on the class. In this example, we set ``template_name``
on the ``TemplateView``. A similar overriding pattern can be used for the
``url`` attribute on :class:`~django.views.generic.base.RedirectView`.


Subclassing generic views
=========================

The second, more powerful way to use generic views is to inherit from an
existing view and override attributes (such as the ``template_name``) or
methods (such as ``get_context_data``) in your subclass to provide new values
or methods. Consider, for example, a view that just displays one template,
``about.html``. Django has a generic view to do this -
:class:`~django.views.generic.base.TemplateView` - so we can just subclass it,
and override the template name::

    # some_app/views.py
    from django.views.generic import TemplateView

    class AboutView(TemplateView):
        template_name = "about.html"

Then we just need to add this new view into our URLconf.
:class:`~django.views.generic.base.TemplateView` is a class, not a function,
so we point the URL to the :meth:`~django.views.generic.base.View.as_view`
class method instead, which provides a function-like entry to class-based
views::

    # urls.py
    from django.conf.urls import url
    from some_app.views import AboutView

    urlpatterns = [
        url(r'^about/$', AboutView.as_view()),
    ]


For more information on how to use the built in generic views, consult the next
topic on :doc:`generic class-based views</topics/class-based-views/generic-display>`.

.. _supporting-other-http-methods:

Supporting other HTTP methods
-----------------------------

Suppose somebody wants to access our book library over HTTP using the views
as an API. The API client would connect every now and then and download book
data for the books published since last visit. But if no new books appeared
since then, it is a waste of CPU time and bandwidth to fetch the books from the
database, render a full response and send it to the client. It might be
preferable to ask the API when the most recent book was published.

We map the URL to book list view in the URLconf::

    from django.conf.urls import url
    from books.views import BookListView

    urlpatterns = [
        url(r'^books/$', BookListView.as_view()),
    ]

And the view::

    from django.http import HttpResponse
    from django.views.generic import ListView
    from books.models import Book

    class BookListView(ListView):
        model = Book

        def head(self, *args, **kwargs):
            last_book = self.get_queryset().latest('publication_date')
            response = HttpResponse('')
            # RFC 1123 date format
            response['Last-Modified'] = last_book.publication_date.strftime('%a, %d %b %Y %H:%M:%S GMT')
            return response

If the view is accessed from a ``GET`` request, a plain-and-simple object
list is returned in the response (using ``book_list.html`` template). But if
the client issues a ``HEAD`` request, the response has an empty body and
the ``Last-Modified`` header indicates when the most recent book was published.
Based on this information, the client may or may not download the full object
list.
