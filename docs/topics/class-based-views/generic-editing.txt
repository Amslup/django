Form handling with Class Based Views
====================================

Form processing generally has 3 paths:

* Initial GET (blank or prepopulated form)
* POST with invalid data
* POST with valid data

Dealing with this using function-based views often results in a lot of
repeated boilerplate code (see 'Using a form in a view'). To help avoid this,
Django provides a collection of generic Class Based Views for form processing.

Basic Forms
-----------

Given a simple contact form::

    # forms.py
    from django import forms

    class ContactForm(forms.Form):
        name = forms.CharField()
        message = forms.CharField(widget=forms.Textarea)

        def send_email(self):
            # send email using the self.cleaned_data dictionary
            pass

The view can be constructed using a FormView::

    # views.py
    from myapp.forms import ContactForm
    from django.views.generic.edit import FormView

    class ContactView(FormView):
        template_name = 'contact.html'
        form_class = ContactForm
        success_url = '/thanks/'

        def form_valid(self, form):
            # This method is called when valid form data has been POSTed.
            # It should return an HttpResponse.
            form.send_email()
            return super(ContactView, self).form_valid(form)

Notes:

* FormView inherits ``TemplateResponseMixin`` so ``template_name`` can be used here
* The default implementation for ``form_valid`` simply redirects to the success_url

Model Forms
-----------

Generic views really shine when working with models.
These generic views will automatically create a ModelForm, so long as
they can work out which model class to use:

* If the ``model`` attribute is given, that model class will be used
* If ``get_object`` returns an object, the class of that object will be used
* If a ``queryset`` is given, the model for that queryset will be used

Model views provide a ``form_valid`` implementation that saves the model
automatically.
You can override/extend this method if you have any special requirements
(see below for examples).

You don't even need to provide a success_url for ``CreateView`` or
``UpdateView`` - they will use ``model.get_absolute_url()`` if available.

If you want to use a custom ``ModelForm`` (to add extra constraints or validation)
simply set :attr:`form_class` to your custom form class.

.. note::
    When specifying a custom form class, you must still specify the model,
    even though the form_class may be a ModelForm.
    (See https://code.djangoproject.com/ticket/15125)

Example of full add/edit/delete for one model::

    # models.py
    from django import models

    class Author(models.Model):
        name = models.CharField(max_length=200)

        def get_absolute_url(self):
            return '/author/%s/' % self.pk
   
    # views.py
    from myapp.models import Author
    from django.views.generic.edit import CreateView, UpdateView, DeleteView

    class AuthorCreate(CreateView):
        model = Author

    class AuthorUpdate(UpdateView):
        model = Author

    class AuthorDelete(DeleteView):
        model = Author
        success_url = '/authors/'

    # urls.py
    from django.conf.urls import patterns, url
    from myapp.views import AuthorCreate, AuthorUpdate, AuthorDelete

    urlpatterns = patterns('',
        url(r'author/add/$', AuthorCreate.as_view(), name='author_add'),
        url(r'author/(?P<pk>\d+)/$', AuthorUpdate.as_view(), name='author_update'),
        url(r'author/(?P<pk>\d+)/delete/$', AuthorDelete.as_view(), name='author_delete'),
    )
        
.. note::
    These views inherit ``SingleObjectTemplateResponseMixin`` which uses
    ``template_name_prefix`` to construct the ``template_name`` based on the model.
    In this example:

    * ``CreateView`` and ``UpdateView`` use ``myapp/author_form.html``
    * ``DeleteView`` uses ``myapp/author_confirm_delete.html``

    If you wish to have separate templates for ``CreateView`` and ``UpdateView``, you
    can set either :attr:`template_name` or :attr:`template_name_suffix` on
    your view class.

Models and request.user
-----------------------

To track the user that created an object using a ``CreateView``, you can do the
following...

First, add the foreign key relation to the model::

    # models.py
    from django import models
    from django.contrib.auth import User

    class Author(models.Model):
        name = models.CharField(max_length=200)
        created_by = models.ForeignKey(User)

        def get_absolute_url(self):
            return '/author/%s/' % self.pk

Create a custom ``ModelForm`` in order to exclude the ``created_by`` field and
prevent the user from editing it:

.. code-block:: python

    # forms.py
    from django import forms
    from myapp.models import Author
    
    class AuthorForm(forms.ModelForm):
        class Meta:
            model = Author
            exclude = ('created_by',)

In the view, use the custom ``form_class`` and override ``form_valid`` to add the user::

    # views.py
    from django.views.generic.edit import CreateView
    from myapp.models import Author
    from myapp.forms import AuthorForm
    
    class AuthorCreate(CreateView):
        form_class = AuthorForm
        model = Author

        def form_valid(self, form):
            form.instance.created_by = self.request.user
            return super(AuthorCreate, self).form_valid(form)
