

Basic usage
-----------

.. _topics-auth-creating-users:

Creating users
~~~~~~~~~~~~~~

The most basic way to create users is to use the
:meth:`~django.contrib.auth.models.UserManager.create_user` helper function
that comes with Django::

    >>> from django.contrib.auth.models import User
    >>> user = User.objects.create_user('john', 'lennon@thebeatles.com', 'johnpassword')

    # At this point, user is a User object that has already been saved
    # to the database. You can continue to change its attributes
    # if you want to change other fields.
    >>> user.is_staff = True
    >>> user.save()

You can also create users using the Django admin site. Assuming you've enabled
the admin site and hooked it to the URL ``/admin/``, the "Add user" page is at
``/admin/auth/user/add/``. You should also see a link to "Users" in the "Auth"
section of the main admin index page. The "Add user" admin page is different
than standard admin pages in that it requires you to choose a username and
password before allowing you to edit the rest of the user's fields.

Also note: if you want your own user account to be able to create users using
the Django admin site, you'll need to give yourself permission to add users
*and* change users (i.e., the "Add user" and "Change user" permissions). If
your account has permission to add users but not to change them, you won't be
able to add users. Why? Because if you have permission to add users, you have
the power to create superusers, which can then, in turn, change other users. So
Django requires add *and* change permissions as a slight security measure.


Changing passwords
~~~~~~~~~~~~~~~~~~

:djadmin:`manage.py changepassword *username* <changepassword>` offers a method
of changing a User's password from the command line. It prompts you to
change the password of a given user which you must enter twice. If
they both match, the new password will be changed immediately. If you
do not supply a user, the command will attempt to change the password
whose username matches the current user.

You can also change a password programmatically, using
:meth:`~django.contrib.auth.models.User.set_password()`:

.. code-block:: python

    >>> from django.contrib.auth.models import User
    >>> u = User.objects.get(username__exact='john')
    >>> u.set_password('new password')
    >>> u.save()

Don't set the :attr:`~django.contrib.auth.models.User.password` attribute
directly unless you know what you're doing. This is explained in the next
section.

--- note to how django stores passwords

Anonymous users
---------------

.. class:: models.AnonymousUser

    :class:`django.contrib.auth.models.AnonymousUser` is a class that
    implements the :class:`django.contrib.auth.models.User` interface, with
    these differences:

    * :attr:`~django.contrib.auth.models.User.id` is always ``None``.
    * :attr:`~django.contrib.auth.models.User.is_staff` and
      :attr:`~django.contrib.auth.models.User.is_superuser` are always
      ``False``.
    * :attr:`~django.contrib.auth.models.User.is_active` is always ``False``.
    * :attr:`~django.contrib.auth.models.User.groups` and
      :attr:`~django.contrib.auth.models.User.user_permissions` are always
      empty.
    * :meth:`~django.contrib.auth.models.User.is_anonymous()` returns ``True``
      instead of ``False``.
    * :meth:`~django.contrib.auth.models.User.is_authenticated()` returns
      ``False`` instead of ``True``.
    * :meth:`~django.contrib.auth.models.User.set_password()`,
      :meth:`~django.contrib.auth.models.User.check_password()`,
      :meth:`~django.contrib.auth.models.User.save()`,
      :meth:`~django.contrib.auth.models.User.delete()`,
      :meth:`~django.contrib.auth.models.User.set_groups()` and
      :meth:`~django.contrib.auth.models.User.set_permissions()` raise
      :exc:`NotImplementedError`.

In practice, you probably won't need to use
:class:`~django.contrib.auth.models.AnonymousUser` objects on your own, but
they're used by Web requests, as explained in the next section.

.. _topics-auth-creating-superusers:

Creating superusers
-------------------

:djadmin:`manage.py syncdb <syncdb>` prompts you to create a superuser the
first time you run it after adding ``'django.contrib.auth'`` to your
:setting:`INSTALLED_APPS`. If you need to create a superuser at a later date,
you can use a command line utility::

    manage.py createsuperuser --username=joe --email=joe@example.com

You will be prompted for a password. After you enter one, the user will be
created immediately. If you leave off the :djadminopt:`--username` or the
:djadminopt:`--email` options, it will prompt you for those values.

If you're using an older release of Django, the old way of creating a superuser
on the command line still works::

    python /path/to/django/contrib/auth/create_superuser.py

...where :file:`/path/to` is the path to the Django codebase on your
filesystem. The ``manage.py`` command is preferred because it figures out the
correct path and environment for you.


Authentication in Web requests
==============================

Until now, this document has dealt with the low-level APIs for manipulating
authentication-related objects. On a higher level, Django can hook this
authentication framework into its system of
:class:`request objects <django.http.HttpRequest>`.

First, install the
:class:`~django.contrib.sessions.middleware.SessionMiddleware` and
:class:`~django.contrib.auth.middleware.AuthenticationMiddleware`
middlewares by adding them to your :setting:`MIDDLEWARE_CLASSES` setting. See
the :doc:`session documentation </topics/http/sessions>` for more information.

Once you have those middlewares installed, you'll be able to access
:attr:`request.user <django.http.HttpRequest.user>` in views.
:attr:`request.user <django.http.HttpRequest.user>` will give you a
:class:`~django.contrib.auth.models.User` object representing the currently
logged-in user. If a user isn't currently logged in,
:attr:`request.user <django.http.HttpRequest.user>` will be set to an instance
of :class:`~django.contrib.auth.models.AnonymousUser` (see the previous
section). You can tell them apart with
:meth:`~django.contrib.auth.models.User.is_authenticated()`, like so::

    if request.user.is_authenticated():
        # Do something for authenticated users.
    else:
        # Do something for anonymous users.

.. _how-to-log-a-user-in:

How to log a user in
--------------------

Django provides two functions in :mod:`django.contrib.auth`:
:func:`~django.contrib.auth.authenticate()` and
:func:`~django.contrib.auth.login()`.

.. function:: authenticate()

    To authenticate a given username and password, use
    :func:`~django.contrib.auth.authenticate()`. It takes two keyword
    arguments, ``username`` and ``password``, and it returns a
    :class:`~django.contrib.auth.models.User` object if the password is valid
    for the given username. If the password is invalid,
    :func:`~django.contrib.auth.authenticate()` returns ``None``. Example::

        from django.contrib.auth import authenticate
        user = authenticate(username='john', password='secret')
        if user is not None:
            if user.is_active:
                print("You provided a correct username and password!")
            else:
                print("Your account has been disabled!")
        else:
            print("Your username and password were incorrect.")

.. function:: login()

    To log a user in, in a view, use :func:`~django.contrib.auth.login()`. It
    takes an :class:`~django.http.HttpRequest` object and a
    :class:`~django.contrib.auth.models.User` object.
    :func:`~django.contrib.auth.login()` saves the user's ID in the session,
    using Django's session framework, so, as mentioned above, you'll need to
    make sure to have the session middleware installed.

    Note that data set during the anonymous session is retained when the user
    logs in.

    This example shows how you might use both
    :func:`~django.contrib.auth.authenticate()` and
    :func:`~django.contrib.auth.login()`::

        from django.contrib.auth import authenticate, login

        def my_view(request):
            username = request.POST['username']
            password = request.POST['password']
            user = authenticate(username=username, password=password)
            if user is not None:
                if user.is_active:
                    login(request, user)
                    # Redirect to a success page.
                else:
                    # Return a 'disabled account' error message
            else:
                # Return an 'invalid login' error message.

.. admonition:: Calling ``authenticate()`` first

    When you're manually logging a user in, you *must* call
    :func:`~django.contrib.auth.authenticate()` before you call
    :func:`~django.contrib.auth.login()`.
    :func:`~django.contrib.auth.authenticate()`
    sets an attribute on the :class:`~django.contrib.auth.models.User` noting
    which authentication backend successfully authenticated that user (see the
    `backends documentation`_ for details), and this information is needed
    later during the login process.

.. _backends documentation: #other-authentication-sources


---link to managing passwords?



How to log a user out
---------------------

.. currentmodule:: django.contrib.auth

.. function:: logout()

    To log out a user who has been logged in via
    :func:`django.contrib.auth.login()`, use
    :func:`django.contrib.auth.logout()` within your view. It takes an
    :class:`~django.http.HttpRequest` object and has no return value.
    Example::

        from django.contrib.auth import logout

        def logout_view(request):
            logout(request)
            # Redirect to a success page.

    Note that :func:`~django.contrib.auth.logout()` doesn't throw any errors if
    the user wasn't logged in.

    When you call :func:`~django.contrib.auth.logout()`, the session data for
    the current request is completely cleaned out. All existing data is
    removed. This is to prevent another person from using the same Web browser
    to log in and have access to the previous user's session data. If you want
    to put anything into the session that will be available to the user
    immediately after logging out, do that *after* calling
    :func:`django.contrib.auth.logout()`.


