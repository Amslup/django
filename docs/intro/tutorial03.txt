=====================================
Writing your first Django app, part 3
=====================================

This tutorial begins where :doc:`Tutorial 2 </intro/tutorial02>` left off. We're
continuing the Web-poll application and will focus on creating the public
interface -- "views."

Philosophy
==========

A view is a "type" of Web page in your Django application that generally serves
a specific function and has a specific template. For example, in a Blog
application, you might have the following views:

* Blog homepage -- displays the latest few entries.

* Entry "detail" page -- permalink page for a single entry.

* Year-based archive page -- displays all months with entries in the
  given year.

* Month-based archive page -- displays all days with entries in the
  given month.

* Day-based archive page -- displays all entries in the given day.

* Comment action -- handles posting comments to a given entry.

In our poll application, we'll have the following four views:

* Poll "index" page -- displays the latest few polls.

* Poll "detail" page -- displays a poll question, with no results but
  with a form to vote.

* Poll "results" page -- displays results for a particular poll.

* Vote action -- handles voting for a particular choice in a particular
  poll.

In Django, each view is represented by a simple Python function.

Write your first view
=====================

Let's write the first view. Open the file ``polls/views.py``
and put the following Python code in it::

    from django.http import HttpResponse

    def index(request):
        return HttpResponse("Hello, world. You're at the poll index.")

This is the simplest view possible in Django.  Now we have a problem, how do we
call the view? For that we need to map it to a URL, 
in Django this is done in a confirguration file called a URLconf. In the polls
directory create a file called 'urls.py'. Your app directory should now look
like::

    polls/
        __init__.py
        admin.py
        models.py
        tests.py
        urls.py
        views.py

In the polls/urls.py file include the following code::

    from __future__ import absolute_import

    from django.conf.urls import patterns, url

    from . import views

    urlpatterns = patterns('',
        url(regex=r'^$',
            view=views.index,
            kwargs={},
            name='index')
    )

The next step is to point the root URLconf at the polls/urls.py module. In the 
``mysite/urls.py`` insert an
:func:`~django.conf.urls.include`, leaving you with::

    from django.conf.urls import patterns, include, url

    from django.contrib import admin
    admin.autodiscover()

    urlpatterns = patterns('',
        url(r'^polls/', include('polls.urls')),
        url(r'^admin/', include(admin.site.urls)),
    )

You have now wired an `index` view into the URLconf. Go to "/polls/" in your 
browser, and you should see the text "*Hello, world. You're at the poll index.*", 
which you defined in the ``index`` view.

The :func:`~django.conf.urls.url` function is being passed four arguments:
``regex``, ``view``, ``kwargs``, and ``name``. At this point, it's worth 
reviewing what the arguments passed into :func:`~django.conf.urls.url` are for:

:func:`~django.conf.urls.url` argument: regex
---------------------------------------------

The term `regex` is a commonly used psuedonym for regular expressions, which is
a syntax for matching patterns in strings, or in this case, url patterns. Django
starts at the first regular expression and makes its way down the list, 
comparing the requested URL against each regular expression until it finds one
that matches.

Note that these regular expressions do not search GET and POST parameters, or
the domain name. For example, in a request to ``http://www.example.com/myapp/``,
the URLconf will look for ``myapp/``. In a request to
``http://www.example.com/myapp/?page=3``, the URLconf will look for ``myapp/``.

If you need help with regular expressions, see `Wikipedia's entry`_ and the
documentation of the :mod:`re` module. Also, the O'Reilly book "Mastering
Regular Expressions" by Jeffrey Friedl is fantastic.

Finally, a performance note: these regular expressions are compiled the first
time the URLconf module is loaded. They're super fast.

.. _Wikipedia's entry: http://en.wikipedia.org/wiki/Regular_expression

:func:`~django.conf.urls.url` argument: view
--------------------------------------------

When Django finds a regex match, Django calls the Python specified view 
function, with an HttpRequest object as the first argument, any “captured” 
values from the regular expression as keyword arguments. Using the tutorial
example, calling ``/polls/12/`` will match the ``detail`` view and pass an 
integer argument of ``12`` to the detail view.

:func:`~django.conf.urls.url` argument: kwargs
----------------------------------------------

Arbitrary keyword arguments can be passed in a dictionary to the target view. We
aren't going to use this feature of Django in the tutorial.

:func:`~django.conf.urls.url` argument: name
---------------------------------------------

Naming URL patterns allows you to fully utilize a number of Django's reverse URL
matching to distinguish between views. This powerful feature allows you to make 
global changes to the url patterns of your project while only touching a single
file.

Writing more views
==================

Now lets add a few more views. These views are slightly different, because
they take an argument::

    def detail(request, poll_id):
        return HttpResponse("You're looking at poll %s." % poll_id)

    def results(request, poll_id):
        return HttpResponse("You're looking at the results of poll %s." % poll_id)

    def vote(request, poll_id):
        return HttpResponse("You're voting on poll %s." % poll_id)

Wire these news views into the polls/urls.py module by adding the following 
``url`` calls as demonstrated below::

    from __future__ import absolute_import

    from django.conf.urls import patterns, url

    from . import views

    urlpatterns = patterns('',
        url(regex=r'^$',
            view=views.index,
            kwargs={},
            name='index'),

        # call the detail view
        url(regex=r'^(?P<poll_id>\d+)/$',
            view=views.detail,
            kwargs={},
            name='detail'),

        # call the results view
        url(regex=r'^(?P<poll_id>\d+)/results/$',
            view=views.results,
            kwargs={},
            name='results'),

        # call the vote view
        url(regex=r'^(?P<poll_id>\d+)/vote/$',
            view=views.vote,
            kwargs={},
            name='vote')
    )

Take a look in your browser, at "/polls/34/". It'll run the `detail()` method
and display whatever ID you provide in the URL. Try "/polls/34/results/" and
"/polls/34/vote/" too -- these will display the placeholder results and voting
pages.

Write views that actually do something
======================================

Each view is responsible for doing one of two things: Returning an
:class:`~django.http.HttpResponse` object containing the content for the
requested page, or raising an exception such as :exc:`~django.http.Http404`. The
rest is up to you.

Your view can read records from a database, or not. It can use a template
system such as Django's -- or a third-party Python template system -- or not.
It can generate a PDF file, output XML, create a ZIP file on the fly, anything
you want, using whatever Python libraries you want.

All Django wants is that :class:`~django.http.HttpResponse`. Or an exception.

Because it's convenient, let's use Django's own database API, which we covered
in :doc:`Tutorial 1 </intro/tutorial01>`. Here's one stab at the ``index()``
view, which displays the latest 5 poll questions in the system, separated by
commas, according to publication date::

    from __future__ import absolute_import

    from django.http import HttpResponse

    from .models import Poll

    def index(request):
        latest_poll_list = Poll.objects.order_by('-pub_date')[:5]
        output = ', '.join([p.question for p in latest_poll_list])
        return HttpResponse(output)

There's a problem here, though: The page's design is hard-coded in the view. If
you want to change the way the page looks, you'll have to edit this Python code.
So let's use Django's template system to separate the design from Python. 

First, create a directory, somewhere on your filesystem, whose contents Django
can access. (Django runs as whatever user your server runs.) Don't put them 
under your document root, though. You probably shouldn't make them public, just
for security's sake. Then edit :setting:`TEMPLATE_DIRS` in your ``settings.py``
to tell Django where it can find templates -- just as you did in the "Customize
the admin look and feel" section of Tutorial 2.

When you've done that, create a directory ``polls`` in your template directory.
Within that, create a file called ``index.html``. Note that our
``loader.get_template('polls/index.html')`` code from above maps to
"[template_directory]/polls/index.html" on the filesystem.

Put the following code in that template:

.. code-block:: html+django

    {% if latest_poll_list %}
        <ul>
        {% for poll in latest_poll_list %}
            <li><a href="/polls/{{ poll.id }}/">{{ poll.question }}</a></li>
        {% endfor %}
        </ul>
    {% else %}
        <p>No polls are available.</p>
    {% endif %}

Now let's call that html template from the index view::

    from __future__ import absolute_import

    from django.http import HttpResponse
    from django.template import Context, loader

    from .models import Poll

    def index(request):
        latest_poll_list = Poll.objects.order_by('-pub_date')[:5]
        t = loader.get_template('polls/index.html')
        c = Context({
            'latest_poll_list': latest_poll_list,
        })
        return HttpResponse(t.render(c))

That code loads the template called "polls/index.html" and passes it a context.
The context is a dictionary mapping template variable names to Python objects.

Load the page in your Web browser, and you should see a bulleted-list
containing the "What's up" poll from Tutorial 1. The link points to the poll's
detail page.

A shortcut: render()
--------------------------------

It's a very common idiom to load a template, fill a context and return an
:class:`~django.http.HttpResponse` object with the result of the rendered
template. Django provides a shortcut. Here's the full ``index()`` view,
rewritten::

    from __future__ import absolute_import

    from django.shortcuts import render
    from .models import Poll

    def index(request):
        latest_poll_list = Poll.objects.all().order_by('-pub_date')[:5]
        return render(
            request, 
            'polls/index.html', 
            {'latest_poll_list': latest_poll_list}
        )

Note that once we've done this in all these views, we no longer need to import
:mod:`~django.template.loader`, :class:`~django.template.Context` and
:class:`~django.http.HttpResponse`.

The :func:`~django.shortcuts.render` function takes a template name
as its first argument and a dictionary as its optional second argument. It
returns an :class:`~django.http.HttpResponse` object of the given template
rendered with the given context.

Raising 404
===========

Now, let's tackle the poll detail view -- the page that displays the question
for a given poll. Here's the view::

    from django.http import Http404
    # ...
    def detail(request, poll_id):
        try:
            p = Poll.objects.get(pk=poll_id)
        except Poll.DoesNotExist:
            raise Http404
        return render(request, 'polls/detail.html', {'poll': p})

The new concept here: The view raises the :exc:`~django.http.Http404` exception
if a poll with the requested ID doesn't exist.

We'll discuss what you could put in that ``polls/detail.html`` template a bit
later, but if you'd like to quickly get the above example working, just::

    {{ poll }}

will get you started for now.

A shortcut: get_object_or_404()
-------------------------------

It's a very common idiom to use :meth:`~django.db.models.query.QuerySet.get`
and raise :exc:`~django.http.Http404` if the object doesn't exist. Django
provides a shortcut. Here's the ``detail()`` view, rewritten::

    from django.shortcuts import render, get_object_or_404
    # ...
    def detail(request, poll_id):
        p = get_object_or_404(Poll, pk=poll_id)
        return render(request, 'polls/detail.html', {'poll': p})

The :func:`~django.shortcuts.get_object_or_404` function takes a Django model
as its first argument and an arbitrary number of keyword arguments, which it
passes to the :meth:`~django.db.models.query.QuerySet.get` function of the
model's manager. It raises :exc:`~django.http.Http404` if the object doesn't
exist.

.. admonition:: Philosophy

    Why do we use a helper function :func:`~django.shortcuts.get_object_or_404`
    instead of automatically catching the
    :exc:`~django.core.exceptions.ObjectDoesNotExist` exceptions at a higher
    level, or having the model API raise :exc:`~django.http.Http404` instead of
    :exc:`~django.core.exceptions.ObjectDoesNotExist`?

    Because that would couple the model layer to the view layer. One of the
    foremost design goals of Django is to maintain loose coupling.

There's also a :func:`~django.shortcuts.get_list_or_404` function, which works
just as :func:`~django.shortcuts.get_object_or_404` -- except using
:meth:`~django.db.models.query.QuerySet.filter` instead of
:meth:`~django.db.models.query.QuerySet.get`. It raises
:exc:`~django.http.Http404` if the list is empty.

Write a 404 (page not found) view
=================================

When you raise :exc:`~django.http.Http404` from within a view, Django
will load a special view devoted to handling 404 errors. It finds it
by looking for the variable ``handler404`` in your root URLconf (and
only in your root URLconf; setting ``handler404`` anywhere else will
have no effect), which is a string in Python dotted syntax -- the same
format the normal URLconf callbacks use. A 404 view itself has nothing
special: It's just a normal view.

You normally won't have to bother with writing 404 views. If you don't set
``handler404``, the built-in view :func:`django.views.defaults.page_not_found`
is used by default. In this case, you still have one obligation: create a
``404.html`` template in the root of your template directory. The default 404
view will use that template for all 404 errors. If :setting:`DEBUG` is set to
``False`` (in your settings module) and if you didn't create a ``404.html``
file, an ``Http500`` is raised instead. So remember to create a ``404.html``.

A couple more things to note about 404 views:

* If :setting:`DEBUG` is set to ``True`` (in your settings module) then your
  404 view will never be used (and thus the ``404.html`` template will never
  be rendered) because the traceback will be displayed instead.

* The 404 view is also called if Django doesn't find a match after checking
  every regular expression in the URLconf.

Write a 500 (server error) view
===============================

Similarly, your root URLconf may define a ``handler500``, which points
to a view to call in case of server errors. Server errors happen when
you have runtime errors in view code.

Use the template system
=======================

Back to the ``detail()`` view for our poll application. Given the context
variable ``poll``, here's what the "polls/detail.html" template might look
like:

.. code-block:: html+django

    <h1>{{ poll.question }}</h1>
    <ul>
    {% for choice in poll.choice_set.all %}
        <li>{{ choice.choice_text }}</li>
    {% endfor %}
    </ul>

The template system uses dot-lookup syntax to access variable attributes. In
the example of ``{{ poll.question }}``, first Django does a dictionary lookup
on the object ``poll``. Failing that, it tries an attribute lookup -- which
works, in this case. If attribute lookup had failed, it would've tried a
list-index lookup.

Method-calling happens in the :ttag:`{% for %}<for>` loop:
``poll.choice_set.all`` is interpreted as the Python code
``poll.choice_set.all()``, which returns an iterable of ``Choice`` objects and is
suitable for use in the :ttag:`{% for %}<for>` tag.

Removing hardcoded URLs in templates
====================================

Remember, when we wrote the link to a poll in the polls/index.html template, 
the link was partially hardcoded like this:

.. code-block:: html+django

    <li><a href="/polls/{{ poll.id }}/">{{ poll.question }}</a></li>

The problem with this hardcoded, tightly-coupled approach is that it becomes
challenging to change URLs on projects with a lot of templates. However, since
you defined the name argument in the :func:`~django.conf.urls.url` functions in 
the ``polls/urls.py`` module, you can decouple the URLs via the ``{% url %}`` 
templatetag:

.. code-block:: html+django

    <li><a href="{% url 'detail' poll.id %}">{{ poll.question }}</a></li>

The way this works is by calling the URL definition as specified in the
``polls/urls.py`` file:. You can see exactly where the URL name of 'detail' is
defined below::

    ...
    # call the detail view
    url(regex=r'^(?P<poll_id>\d+)/$',
        view=views.detail,
        kwargs={},
        name='detail'), # the 'name' value as called by the {% url %} template tag
    ...

If you want to change the URL of the polls detail view to something else, 
perhaps to something like ``polls/specifics/12/`` instead of doing it in the
template (or templates) you would change it in ``polls/urls.py``::

    ...
    # call the detail view
    url(regex=r'^specifics/(?P<poll_id>\d+)/$', # added the word 'specifics'
        view=views.detail,
        kwargs={},
        name='detail'), # the 'name' value as called by the {% url %} template tag
    ...

See the :doc:`template guide </topics/templates>` for more about templates.


Namespacing URL names
======================

The tutorial project has just one app, ``polls``. In real Django projects, there
might be five, ten, eighty apps or more. How does Django differentiate the URL
names between them? For example, the ``polls`` app has a ``detail`` view, and so
might an app on the same project that is for a blog. How does one make it so
that Django knows which app view to create for a url when using the ``{% url %}``
template tag?

The answer to add namespaces to your root URLconf. In the mysite/urls.py file,
go ahead and change it to include namespacing::

    from django.conf.urls import patterns, include, url

    from django.contrib import admin
    admin.autodiscover()

    urlpatterns = patterns('',
        url(r'^polls/', include('polls.urls', namespace="polls")),
        url(r'^admin/', include(admin.site.urls)),
    )

Now change your ``polls/index.html`` template from:

.. code-block:: html+django

    <li><a href="{% url 'detail' poll.id %}">{{ poll.question }}</a></li>

to point at the namespaced detail view:

.. code-block:: html+django

    <li><a href="{% url 'polls:detail' poll.id %}">{{ poll.question }}</a></li>


About the root URLconf
=================================================================

You've probably noticed by now that ``mysite/urls.py`` calls both the polls app
and the admin app. It's what is called the root URLconf, and is important when
building Django projects.

The :func:`~django.conf.urls.include` functions we are using in the tutorial
simply references another URLconf. Note that the regular expression doesn't have
a ``$`` (end-of-string match character) but has the trailing slash. Whenever
Django encounters :func:`~django.conf.urls.include`, it chops off whatever part
of the URL matched up to that point and sends the remaining string to the
included URLconf for further processing.

The idea behind :func:`~django.conf.urls.include` is to make it easy to 
plug-and-play URLs. Since polls are in their own URLconf
(``polls/urls.py``), they can be placed under "/polls/", or under 
"/fun_polls/", or under "/content/polls/", or any other path root, and the
app will still work.

All the poll app cares about is its relative path, not its absolute path.

When you're comfortable with writing views, read :doc:`part 4 of this tutorial
</intro/tutorial04>` to learn about simple form processing and generic views.
