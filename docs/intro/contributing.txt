===================================
Writing your first patch for Django
===================================

Introduction
============

Interested in giving back to the community a little? Maybe you've found a bug
in Django that you'd like to see fixed, or maybe there's a small feature you
want added.

Contributing back to Django itself is the best way to see your own concerns
addressed. This may seem daunting at first, but it's really pretty simple.
We'll walk you through the entire process, so you can learn by example.

Who's this tutorial for?
------------------------

.. seealso::

    If you are looking for a reference on how to submit patches, see the
    :doc:`/internals/contributing/writing-code/submitting-patches`
    documentation.

For this tutorial, we expect that you have at least a basic understanding of
how Django works. This means you should be comfortable going through the
existing tutorials on :doc:`writing your first Django app</intro/tutorial01>`.
In addition, you should have a good understanding of Python itself. But if you
don't, `Dive Into Python`__ is a fantastic (and free) online book for
beginning Python programmers.

Those of you who are unfamiliar with version control systems and Trac will find
that this tutorial and its links include just enough information to get started.
However, you'll probably want to read some more about these different tools if
you plan on contributing to Django regularly.

For the most part though, this tutorial tries to explain as much as possible,
so that it can be of use to the widest audience.

.. admonition:: Where to get help:

    If you're having trouble going through this tutorial, please post a message
    to |django-developers| or drop by `#django-dev on irc.freenode.net`__ to
    chat with other Django users who might be able to help.

__ http://www.diveintopython3.net/
__ irc://irc.freenode.net/django-dev

What does this tutorial cover?
------------------------------

We'll be walking you through contributing a patch to Django for the first time.
By the end of this tutorial, you should have a basic understanding of both the
tools and the processes involved. Specifically, we'll be covering the following:

* Installing Git.
* How to download a development copy of Django.
* Running Django's test suite.
* Writing a test for your patch.
* Writing the code for your patch.
* Testing your patch.
* Writing documentation for your patch.
* Submitting a pull request.
* Where to look for more information.

Once you're done with the tutorial, you can look through the rest of
:doc:`Django's documentation on contributing</internals/contributing/index>`.
It contains lots of great information and is a must read for anyone who'd like
to become a regular contributor to Django. If you've got questions, it's
probably got the answers.

.. admonition:: Python 3 required!

    The current development version of Django doesn't support Python 2.7. Get
    Python 3 at `Python's download page <https://www.python.org/downloads/>`_ or
    with your operating system's package manager.

.. admonition:: For Windows users

    When installing Python on Windows, make sure you check the option "Add
    python.exe to Path", so that it is always available on the command line.

Code of Conduct
===============

As a contributor, you can help us keep the Django community open and inclusive.
Please read and follow our `Code of Conduct <https://www.djangoproject.com/conduct/>`_.

Installing Git
==============

For this tutorial, you'll need Git installed to download the current
development version of Django and to generate patch files for the changes you
make.

To check whether or not you have Git installed, enter ``git`` into the command
line. If you get messages saying that this command could not be found, you'll
have to download and install it, see `Git's download page`__.

.. admonition:: For Windows users

    When installing Git on Windows, it is recommended that you pick the
    "Git Bash" option so that Git runs in its own shell. This tutorial assumes
    that's how you have installed it.

If you're not that familiar with Git, you can always find out more about its
commands (once it's installed) by typing ``git help`` into the command line.

__ https://git-scm.com/download

Getting a copy of Django's development version
==============================================

The first step to contributing to Django is to get a copy of the source code.
First, `fork Django on GitHub <https://github.com/django/django/fork>`__. Then,
from the command line, use the ``cd`` command to navigate to the directory
where you'll want your local copy of Django to live.

Download the Django source code repository using the following command:

.. code-block:: console

    $ git clone git@github.com:YourGitHubName/django.git

Now that you have a local copy of Django, you can install it just like you would
install any package using ``pip``. The most convenient way to do so is by using
a *virtual environment* (or virtualenv) which is a feature built into Python
that allows you to keep a separate directory of installed packages for each of
your projects so that they don't interfere with each other.

It's a good idea to keep all your virtualenvs in one place, for example in
``.virtualenvs/`` in your home directory. Create it if it doesn't exist yet:

.. code-block:: console

    $ mkdir ~/.virtualenvs

Now create a new virtualenv by running:

.. code-block:: console

    $ python3 -m venv ~/.virtualenvs/djangodev

The path is where the new environment will be saved on your computer.

.. admonition:: For Windows users

    Using the built-in ``venv`` module will not work if you are also using the
    Git Bash shell on Windows, since activation scripts are only created for the
    system shell (``.bat``) and PowerShell (``.ps1``). Use the ``virtualenv``
    package instead:

    .. code-block:: none

        $ pip install virtualenv
        $ virtualenv ~/.virtualenvs/djangodev

.. admonition:: For Ubuntu users

    On some versions of Ubuntu the above command might fail. Use the
    ``virtualenv`` package instead, first making sure you have ``pip3``:

    .. code-block:: console

        $ sudo apt-get install python3-pip
        $ # Prefix the next command with sudo if it gives a permission denied error
        $ pip3 install virtualenv
        $ virtualenv --python=`which python3` ~/.virtualenvs/djangodev

The final step in setting up your virtualenv is to activate it:

.. code-block:: console

    $ source ~/.virtualenvs/djangodev/bin/activate

If the ``source`` command is not available, you can try using a dot instead:

.. code-block:: console

    $ . ~/.virtualenvs/djangodev/bin/activate

.. admonition:: For Windows users

    To activate your virtualenv on Windows, run:

    .. code-block:: none

        $ source ~/virtualenvs/djangodev/Scripts/activate

You have to activate the virtualenv whenever you open a new terminal window.
virtualenvwrapper__ is a useful tool for making this more convenient.

__ https://virtualenvwrapper.readthedocs.io/en/latest/

Anything you install through ``pip`` from now on will be installed in your new
virtualenv, isolated from other environments and system-wide packages. Also, the
name of the currently activated virtualenv is displayed on the command line to
help you keep track of which one you are using. Go ahead and install the
previously cloned copy of Django:

.. code-block:: console

    $ pip install -e /path/to/your/local/clone/django/

The installed version of Django is now pointing at your local copy. You will
immediately see any changes you make to it, which is of great help when writing
your first patch.

Rolling back to a previous revision of Django
=============================================

For this tutorial, we'll be using ticket :ticket:`5851` as a case study, so
we'll rewind Django's version history in git to before that ticket's patch was
applied. This will allow us to go through all of the steps involved in writing
that patch from scratch, including running Django's test suite.

**Keep in mind that while we'll be using an older revision of Django's master
branch for the purposes of the tutorial below, you should always use the current
development revision of Django when working on your own patch for a ticket!**

.. note::

    The patch for this ticket was written by Mariusz Felisiak, and it was
    applied to Django as `commit 0034e9af18f3d393a6dd2389ffbba4c919b1d7d7`__.
    Consequently, we'll be using the revision of Django just prior to that,
    `commit 3a148f958dddd97c1379081118c30fbede6b6bc4`__.

__ https://github.com/django/django/commit/0034e9af18f3d393a6dd2389ffbba4c919b1d7d7
__ https://github.com/django/django/commit/3a148f958dddd97c1379081118c30fbede6b6bc4

Navigate into Django's root directory (that's the one that contains ``django``,
``docs``, ``tests``, ``AUTHORS``, etc.). You can then check out the older
revision of Django that we'll be using in the tutorial below:

.. code-block:: console

    $ git checkout 3a148f958dddd97c1379081118c30fbede6b6bc4

Running Django's test suite for the first time
==============================================

When contributing to Django it's very important that your code changes don't
introduce bugs into other areas of Django. One way to check that Django still
works after you make your changes is by running Django's test suite. If all
the tests still pass, then you can be reasonably sure that your changes
haven't completely broken Django. If you've never run Django's test suite
before, it's a good idea to run it once beforehand just to get familiar with
what its output is supposed to look like.

Before running the test suite, install its dependencies by first ``cd``-ing
into the Django ``tests/`` directory and then running:

.. code-block:: console

    $ pip install -r requirements/py3.txt

If you encounter an error during the installation, your system might be missing
a dependency for one or more of the Python packages. Consult the failing
package's documentation or search the Web with the error message that you
encounter.

Now we are ready to run the test suite. If you're using GNU/Linux, macOS, or
some other flavor of Unix, run:

.. code-block:: console

    $ ./runtests.py

Now sit back and relax. Django's entire test suite has over 10,000 different
tests, so it can take anywhere from 3 to 15 minutes to run, depending on the
speed of your computer.

While Django's test suite is running, you'll see a stream of characters
representing the status of each test as it's run. ``E`` indicates that an error
was raised during a test, and ``F`` indicates that a test's assertions failed.
Both of these are considered to be test failures. Meanwhile, ``x`` and ``s``
indicated expected failures and skipped tests, respectively. Dots indicate
passing tests.

Skipped tests are typically due to missing external libraries required to run
the test; see :ref:`running-unit-tests-dependencies` for a list of dependencies
and be sure to install any for tests related to the changes you are making (we
won't need any for this tutorial). Some tests are specific to a particular
database backend and will be skipped if not testing with that backend. SQLite
is the database backend for the default settings. To run the tests using a
different backend, see :ref:`running-unit-tests-settings`.

Once the tests complete, you should be greeted with a message informing you
whether the test suite passed or failed. Since you haven't yet made any changes
to Django's code, the entire test suite **should** pass. If you get failures or
errors make sure you've followed all of the previous steps properly. See
:ref:`running-unit-tests` for more information.

Note that the latest Django trunk may not always be stable. When developing
against trunk, you can check `Django's continuous integration builds`__ to
determine if the failures are specific to your machine or if they are also
present in Django's official builds. If you click to view a particular build,
you can view the "Configuration Matrix" which shows failures broken down by
Python version and database backend.

__ https://djangoci.com

.. note::

    For this tutorial and the ticket we're working on, testing against SQLite
    is sufficient, however, it's possible (and sometimes necessary) to
    :ref:`run the tests using a different database
    <running-unit-tests-settings>`.

Creating a branch for your patch
================================

Before making any changes, create a new branch for the ticket:

.. code-block:: console

    $ git checkout -b ticket_5851

You can choose any name that you want for the branch, "ticket_5851" is an
example. All changes made in this branch will be specific to the ticket and
won't affect the main copy of the code that we cloned earlier.

Writing some tests for your ticket
==================================

In most cases, for a patch to be accepted into Django it has to include tests.
For bug fix patches, this means writing a regression test to ensure that the
bug is never reintroduced into Django later on. A regression test should be
written in such a way that it will fail while the bug still exists and pass
once the bug has been fixed. For patches containing new features, you'll need
to include tests which ensure that the new features are working correctly.
They too should fail when the new feature is not present, and then pass once it
has been implemented.

A good way to do this is to write your new tests first, before making any
changes to the code. This style of development is called
`test-driven development`__ and can be applied to both entire projects and
single patches. After writing your tests, you then run them to make sure that
they do indeed fail (since you haven't fixed that bug or added that feature
yet). If your new tests don't fail, you'll need to fix them so that they do.
After all, a regression test that passes regardless of whether a bug is present
is not very helpful at preventing that bug from reoccurring down the road.

Now for our hands-on example.

__ https://en.wikipedia.org/wiki/Test-driven_development

Writing tests for ticket #5851
------------------------------

Ticket :ticket:`5851` aims to implement the ability to specify different HTML
attributes for the ``DateInput`` and ``TimeInput`` widgets created by
``SplitDateTimeWidget``.

In order to resolve this ticket, you'll modify the ``__init__`` code for the
``SplitDateTimeWidget`` class.

But first, write a test confirming that the  widgets can be created
by ``SplitDateTimeWidget`` with different HTML attributes. This test should fail
until you have completed implementation of the new feature.

Navigate to Django's ``tests/forms_tests/widget_tests/`` folder and open the
``test_splitdatetimewidget.py`` file. Add the following code on line 40 right
above the ``test_formatting`` function::

    def test_constructor_different_attrs(self):
        html = (
            '<input type="text" class="foo" value="2006-01-10" name="date_0" />'
            '<input type="text" class="bar" value="07:30:00" name="date_1" />'
        )
        widget = SplitDateTimeWidget(date_attrs={'class': 'foo'}, time_attrs={'class': 'bar'})
        self.check_html(widget, 'date', datetime(2006, 1, 10, 7, 30), html=html)
        widget = SplitDateTimeWidget(date_attrs={'class': 'foo'}, attrs={'class': 'bar'})
        self.check_html(widget, 'date', datetime(2006, 1, 10, 7, 30), html=html)
        widget = SplitDateTimeWidget(time_attrs={'class': 'bar'}, attrs={'class': 'foo'})
        self.check_html(widget, 'date', datetime(2006, 1, 10, 7, 30), html=html)

This test checks that ``SplitDateTimeWidget`` can accept ``date_attrs`` and
``time_attrs`` kwargs and that those values are applied to the rendered widgets.

.. admonition:: But this testing thing looks kinda hard...

    If you've never had to deal with tests before, they can look a little hard
    to write at first glance. Fortunately, testing is a *very* big subject in
    computer programming, so there's lots of information out there:

    * A good first look at writing tests for Django can be found in the
      documentation on :doc:`/topics/testing/overview`.
    * Dive Into Python (a free online book for beginning Python developers)
      includes a great `introduction to Unit Testing`__.
    * After reading those, if you want something a little meatier to sink
      your teeth into, there's always the Python :mod:`unittest` documentation.

__ http://www.diveintopython3.net/unit-testing.html

Running your new test
---------------------

Remember that you haven't actually made any modifications to
``SplitDateTimeWidget`` yet, so your test is going to fail. Run all the
tests in the ``forms_tests/widget_tests`` folder to make sure that's really what
happens. From the command line, ``cd`` into the Django ``tests/`` directory and
run:

.. code-block:: console

    $ ./runtests.py forms_tests/widget_tests/

If the tests ran correctly, you should see one failure corresponding to the test
method we added. If all of the tests passed, then you'll want to make sure that
you added the new test shown above to the appropriate folder and class.

Writing the code for your ticket
================================

Next you'll be adding the functionality described in ticket :ticket:`5851` to
Django.

Writing the code for ticket #5851
----------------------------------

Navigate to the ``django/forms/`` folder and open the ``widgets.py``
file. Find the ``SplitDateTimeWidget`` class on line 851. Beginning on line 858,
replace the ``__init__`` function with the following code::

    def __init__(self, attrs=None, date_format=None, time_format=None, date_attrs=None, time_attrs=None):
        widgets = (
            DateInput(
                attrs=attrs if date_attrs is None else date_attrs,
                format=date_format
            ),
            TimeInput(
                attrs=attrs if time_attrs is None else time_attrs,
                format=time_format),
        )
        super().__init__(widgets)

Great, ``SplitDateTimeWidget`` can now accept different attributes for its'
``DateInput`` and ``TimeInput`` widgets! But wait, there's an additional class,
``SplitHiddenDateTimeWidget``, which inherits from ``SplitDateTimeWidget``. You
need to make sure it supports the new functionality. Modify the
``__init__`` function there as well.

Starting on line 884, replace the first two lines of the ``__init__`` function
with::

    def __init__(self, attrs=None, date_format=None, time_format=None, date_attrs=None, time_attrs=None):
        super().__init__(attrs, date_format, time_format, date_attrs, time_attrs)


Verifying your test now passes
------------------------------

Once you're done modifying Django, you need to make sure that your new test now
passes, so we can see whether the code we wrote above is working
correctly. To run the tests in the ``forms_tests/widget_tests`` folder, ``cd``
into the Django ``tests/`` directory and run:

.. code-block:: console

    $ ./runtests.py forms_tests/widget_tests/

All tests should pass. If they don't, make sure you
correctly modified the ``SplitDateTimeWidget`` class as shown above and
implemented the new test correctly.

Running Django's test suite for the second time
===============================================

Once you've verified that your patch and your test are working correctly, it's
a good idea to run the entire Django test suite just to verify that your change
hasn't introduced any bugs into other areas of Django. While successfully
passing the entire test suite doesn't guarantee your code is bug free, it does
help identify many bugs and regressions that might otherwise go unnoticed.

To run the entire Django test suite, ``cd`` into the Django ``tests/``
directory and run:

.. code-block:: console

    $ ./runtests.py

As long as you don't see any failures, you're good to go.

Writing Documentation
=====================

This is a new feature and it should be documented so that other users can make
use of it. Update the existing documentation for ``SplitDateTimeWidget``
to reflect our changes. Within ``docs/ref/forms/widgets.txt``, modify
line 843 to::

    ``SplitDateTimeWidget`` has several optional arguments:

and add the following block starting at line 853::

    .. attribute:: SplitDateTimeWidget.date_attrs
    .. attribute:: SplitDateTimeWidget.time_attrs

    .. versionadded:: 2.0

    Similar to :attr:`Widget.attrs`. A dictionary containing HTML
    attributes to be set on the rendered :class:`DateInput` and
    :class:`TimeInput` widgets, respectively. If these attributes aren't
    set, :attr:`Widget.attrs` is used instead.


Since this new feature will be in an upcoming release it is also added to the
release notes for Django 2.0, on line 142 under the "Forms" section in the file
``docs/releases/2.0.txt``::

    * The new ``date_attrs`` and ``time_attrs`` arguments for
      :class:`~django.forms.SplitDateTimeWidget` and
      :class:`~django.forms.SplitHiddenDateTimeWidget` allow specifying different
      HTML attributes for the ``DateInput`` and ``TimeInput`` (or hidden)
      subwidgets.

For more information on writing documentation, including an explanation of what
the ``versionadded`` bit is all about, see
:doc:`/internals/contributing/writing-documentation`. That page also includes
an explanation of how to build a copy of the documentation locally, so you can
preview the HTML that will be generated

.. note::
  Not all patches will contain documentation updates. If, like our example,
  yours does, building the documentation locally is an essential step to ensure
  it is free from build errors/warnings and that the generated HTML is as
  expected.

  To build the documentation changes here, you'll need to install `Sphinx`__
  1.5.6 and run the ``make html`` command from the ``docs/`` directory.

  __ http://www.sphinx-doc.org

  .. code-block:: console

      $ pip install "sphinx<1.6"


Previewing your changes
=======================

Now it's time to go through all the changes made in our patch. To display the
differences between your current copy of Django (with your changes) and the
revision that you initially checked out earlier in the tutorial:

.. code-block:: console

    $ git diff

Use the arrow keys to move up and down.

.. code-block:: diff

    diff --git a/django/forms/widgets.py b/django/forms/widgets.py
    index c468e7d799..78e21e5c3b 100644
    --- a/django/forms/widgets.py
    +++ b/django/forms/widgets.py
    @@ -855,12 +855,18 @@ class SplitDateTimeWidget(MultiWidget):
     supports_microseconds = False
     template_name = 'django/forms/widgets/splitdatetime.html'

    -    def __init__(self, attrs=None, date_format=None, time_format=None):
    +    def __init__(self, attrs=None, date_format=None, time_format=None, date_attrs=None, time_attrs=None):
         widgets = (
    -            DateInput(attrs=attrs, format=date_format),
    -            TimeInput(attrs=attrs, format=time_format),
    +            DateInput(
    +                attrs=attrs if date_attrs is None else date_attrs,
    +                format=date_format
    +            ),
    +            TimeInput(
    +                attrs=attrs if time_attrs is None else time_attrs,
    +                format=time_format
    +            ),
         )
    -        super().__init__(widgets, attrs)
    +        super().__init__(widgets)

     def decompress(self, value):
         if value:
    @@ -875,8 +881,8 @@ class SplitHiddenDateTimeWidget(SplitDateTimeWidget):
     """
     template_name = 'django/forms/widgets/splithiddendatetime.html'

    -    def __init__(self, attrs=None, date_format=None, time_format=None):
    -        super().__init__(attrs, date_format, time_format)
    +    def __init__(self, attrs=None, date_format=None, time_format=None, date_attrs=None, time_attrs=None):
    +        super().__init__(attrs, date_format, time_format, date_attrs, time_attrs)
         for widget in self.widgets:
             widget.input_type = 'hidden'


    diff --git a/docs/ref/forms/widgets.txt b/docs/ref/forms/widgets.txt
    index 9f3ea2840c..39df29914a 100644
    --- a/docs/ref/forms/widgets.txt
    +++ b/docs/ref/forms/widgets.txt
    @@ -840,7 +840,7 @@ Composite widgets
     for the date, and :class:`TimeInput` for the time. Must be used with
     :class:`SplitDateTimeField` rather than :class:`DateTimeField`.

    -    ``SplitDateTimeWidget`` has two optional attributes:
    +    ``SplitDateTimeWidget`` has several optional attributes:

     .. attribute:: SplitDateTimeWidget.date_format

    @@ -850,6 +850,16 @@ Composite widgets

         Similar to :attr:`TimeInput.format`

    +    .. attribute:: SplitDateTimeWidget.date_attrs
    +    .. attribute:: SplitDateTimeWidget.time_attrs
    +
    +    .. versionadded:: 2.0
    +
    +    Similar to :attr:`Widget.attrs`. A dictionary containing HTML
    +    attributes to be set on the rendered :class:`DateInput` and
    +    :class:`TimeInput` widgets, respectively. If these attributes aren't
    +    set, :attr:`Widget.attrs` is used instead.
    +
    ``SplitHiddenDateTimeWidget``
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    diff --git a/tests/forms_tests/widget_tests/test_splitdatetimewidget.py b/tests/forms_tests/widget_tests/test_splitdatetimewidget.py
    index 172bcbbe8d..3b06fd5958 100644
    --- a/tests/forms_tests/widget_tests/test_splitdatetimewidget.py
    +++ b/tests/forms_tests/widget_tests/test_splitdatetimewidget.py
    @@ -37,6 +37,18 @@ class SplitDateTimeWidgetTest(WidgetTest):
             '<input type="text" class="pretty" value="07:30:00" name="date_1" />'
         ))

    +    def test_constructor_different_attrs(self):
    +        html = (
    +            '<input type="text" class="foo" value="2006-01-10" name="date_0" />'
    +            '<input type="text" class="bar" value="07:30:00" name="date_1" />'
    +        )
    +        widget = SplitDateTimeWidget(date_attrs={'class': 'foo'}, time_attrs={'class': 'bar'})
    +        self.check_html(widget, 'date', datetime(2006, 1, 10, 7, 30), html=html)
    +        widget = SplitDateTimeWidget(date_attrs={'class': 'foo'}, attrs={'class': 'bar'})
    +        self.check_html(widget, 'date', datetime(2006, 1, 10, 7, 30), html=html)
    +        widget = SplitDateTimeWidget(time_attrs={'class': 'bar'}, attrs={'class': 'foo'})
    +        self.check_html(widget, 'date', datetime(2006, 1, 10, 7, 30), html=html)
    +
     def test_formatting(self):
         """
         Use 'date_format' and 'time_format' to change the way a value is

When you're done previewing the patch, hit the ``q`` key to return to the
command line. If the patch's content looked okay, it's time to commit the
changes.

Committing the changes in the patch
===================================

To commit the changes:

.. code-block:: console

    $ git commit -a

This opens up a text editor to type the commit message. Follow the :ref:`commit
message guidelines <committing-guidelines>` and write a message like:

.. code-block:: text

    Fixed #5851 -- Allowed specifying different HTML attrs for SplitDateTimeWidget subwidgets.

Pushing the commit and making a pull request
============================================

After committing the patch, send it to your fork on GitHub (substitute
"ticket_5851" with the name of your branch if it's different):

.. code-block:: console

    $ git push origin ticket_5851

You can create a pull request by visiting the `Django GitHub page
<https://github.com/django/django/>`_. You'll see your branch under "Your
recently pushed branches". Click "Compare & pull request" next to it.

**Please don't do it for this tutorial**, but on the next page that displays a
preview of the patch, you would click "Create pull request".

Next steps
==========

Congratulations, you've learned how to make a pull request to Django! Details
of more advanced techniques you may need are in
:doc:`/internals/contributing/writing-code/working-with-git`.

Now you can put those skills to good use by helping to improve Django's
codebase.

More information for new contributors
-------------------------------------

Before you get too into writing patches for Django, there's a little more
information on contributing that you should probably take a look at:

* You should make sure to read Django's documentation on
  :doc:`claiming tickets and submitting patches
  </internals/contributing/writing-code/submitting-patches>`.
  It covers Trac etiquette, how to claim tickets for yourself, expected
  coding style for patches, and many other important details.
* First time contributors should also read Django's :doc:`documentation
  for first time contributors</internals/contributing/new-contributors/>`.
  It has lots of good advice for those of us who are new to helping out
  with Django.
* After those, if you're still hungry for more information about
  contributing, you can always browse through the rest of
  :doc:`Django's documentation on contributing</internals/contributing/index>`.
  It contains a ton of useful information and should be your first source
  for answering any questions you might have.

Finding your first real ticket
------------------------------

Once you've looked through some of that information, you'll be ready to go out
and find a ticket of your own to write a patch for. Pay special attention to
tickets with the "easy pickings" criterion. These tickets are often much
simpler in nature and are great for first time contributors. Once you're
familiar with contributing to Django, you can move on to writing patches for
more difficult and complicated tickets.

If you just want to get started already (and nobody would blame you!), try
taking a look at the list of `easy tickets that need patches`__ and the
`easy tickets that have patches which need improvement`__. If you're familiar
with writing tests, you can also look at the list of
`easy tickets that need tests`__. Just remember to follow the guidelines about
claiming tickets that were mentioned in the link to Django's documentation on
:doc:`claiming tickets and submitting patches
</internals/contributing/writing-code/submitting-patches>`.

__ https://code.djangoproject.com/query?status=new&status=reopened&has_patch=0&easy=1&col=id&col=summary&col=status&col=owner&col=type&col=milestone&order=priority
__ https://code.djangoproject.com/query?status=new&status=reopened&needs_better_patch=1&easy=1&col=id&col=summary&col=status&col=owner&col=type&col=milestone&order=priority
__ https://code.djangoproject.com/query?status=new&status=reopened&needs_tests=1&easy=1&col=id&col=summary&col=status&col=owner&col=type&col=milestone&order=priority

What's next after creating a pull request?
------------------------------------------

After a ticket has a patch, it needs to be reviewed by a second set of eyes.
After submitting a pull request, update the ticket metadata by setting the
flags on the ticket to say "has patch", "doesn't need tests", etc, so others
can find it for review. Contributing doesn't necessarily always mean writing a
patch from scratch. Reviewing existing patches is also a very helpful
contribution. See :doc:`/internals/contributing/triaging-tickets` for details.
