.. _csrf-protection-reference:

=====================================
Cross Site Request Forgery protection
=====================================

.. module:: django.middleware.csrf
   :synopsis: Protects against Cross Site Request Forgeries

See also:

 * :ref:`How to implement CSRF protection <using-csrf>`
 * :ref:`CSRF protection background, policies and limitations
   <cross-site-scripting>`

The CSRF middleware and template tag provides easy-to-use protection against
`Cross Site Request Forgeries`_. This type of attack occurs when a malicious
website contains a link, a form button or some JavaScript that is intended to
perform some action on your website, using the credentials of a logged-in user
who visits the malicious site in their browser. A related type of attack,
'login CSRF', where an attacking site tricks a user's browser into logging into
a site with someone else's credentials, is also covered.

The first defense against CSRF attacks is to ensure that GET requests (and other
'safe' methods, as defined by :rfc:`7231#section-4.2.1`) are side-effect free.
Requests via 'unsafe' methods, such as POST, PUT, and DELETE, can then be
protected by following the steps outlined in :ref:`using-csrf`.

.. _Cross Site Request Forgeries: https://www.squarefree.com/securitytips/web-developers.html#CSRF

.. _csrf-protection-utilities:

Utilities
=========

.. module:: django.views.decorators.csrf

The examples below assume you are using function-based views. If you
are working with class-based views, you can refer to :ref:`Decorating
class-based views<decorating-class-based-views>`.

These utility functions are likely to be useful in a number of :ref:`special cases <csrf-edge-cases>`.

.. function:: csrf_exempt(view)

    This decorator marks a view as being exempt from the protection ensured by
    the middleware. Example::

        from django.http import HttpResponse
        from django.views.decorators.csrf import csrf_exempt

        @csrf_exempt
        def my_view(request):
            return HttpResponse('Hello world')

.. function:: requires_csrf_token(view)

    Normally the :ttag:`csrf_token` template tag will not work if
    ``CsrfViewMiddleware.process_view`` or an equivalent like ``csrf_protect``
    has not run. The view decorator ``requires_csrf_token`` can be used to
    ensure the template tag does work. This decorator works similarly to
    ``csrf_protect``, but never rejects an incoming request.

    Example::

        from django.shortcuts import render
        from django.views.decorators.csrf import requires_csrf_token

        @requires_csrf_token
        def my_view(request):
            c = {}
            # ...
            return render(request, "a_template.html", c)

.. function:: ensure_csrf_cookie(view)

    This decorator forces a view to send the CSRF cookie.


Settings
========

A number of settings can be used to control Django's CSRF behavior:

* :setting:`CSRF_COOKIE_AGE`
* :setting:`CSRF_COOKIE_DOMAIN`
* :setting:`CSRF_COOKIE_HTTPONLY`
* :setting:`CSRF_COOKIE_NAME`
* :setting:`CSRF_COOKIE_PATH`
* :setting:`CSRF_COOKIE_SAMESITE`
* :setting:`CSRF_COOKIE_SECURE`
* :setting:`CSRF_FAILURE_VIEW`
* :setting:`CSRF_HEADER_NAME`
* :setting:`CSRF_TRUSTED_ORIGINS`
* :setting:`CSRF_USE_SESSIONS`

Frequently Asked Questions
==========================

Is posting an arbitrary CSRF token pair (cookie and POST data) a vulnerability?
-------------------------------------------------------------------------------

No, this is by design. Without a man-in-the-middle attack, there is no way for
an attacker to send a CSRF token cookie to a victim's browser, so a successful
attack would need to obtain the victim's browser's cookie via XSS or similar,
in which case an attacker usually doesn't need CSRF attacks.

Some security audit tools flag this as a problem but as mentioned before, an
attacker cannot steal a user's browser's CSRF cookie. "Stealing" or modifying
*your own* token using Firebug, Chrome dev tools, etc. isn't a vulnerability.

Is it a problem that Django's CSRF protection isn't linked to a session by default?
-----------------------------------------------------------------------------------

No, this is by design. Not linking CSRF protection to a session allows using
the protection on sites such as a *pastebin* that allow submissions from
anonymous users which don't have a session.

If you wish to store the CSRF token in the user's session, use the
:setting:`CSRF_USE_SESSIONS` setting.

Why might a user encounter a CSRF validation failure after logging in?
----------------------------------------------------------------------

For security reasons, CSRF tokens are rotated each time a user logs in. Any
page with a form generated before a login will have an old, invalid CSRF token
and need to be reloaded. This might happen if a user uses the back button after
a login or if they log in a different browser tab.
