============
Encoded data
============

Python uses the concepts of text and bytes when dealing with data.
All text is Unicode by default. Providing your database can store the data,
you can safely pass around string to templates, models, and the database.

This document tells you what you need to know if you're writing applications
that use data or templates that are encoded in something other than UTF-8.

Creating the database
=====================

Make sure your database is configured to be able to store arbitrary string
data. Normally, this means giving it an encoding of UTF-8 or UTF-16. If you use
a more restrictive encoding -- for example, latin1 (iso8859-1) -- you won't be
able to store certain characters in the database, and information will be lost.

* MySQL users, refer to the `MySQL manual`_ for details on how to set or alter
  the database character set encoding.

* PostgreSQL users, refer to the `PostgreSQL manual`_ (section 22.3.2 in
  PostgreSQL 9) for details on creating databases with the correct encoding.

* Oracle users, refer to the `Oracle manual`_ for details on how to set
  (`section 2`_) or alter (`section 11`_) the database character set encoding.

* SQLite users, there is nothing you need to do. SQLite always uses UTF-8
  for internal encoding.

.. _MySQL manual: https://dev.mysql.com/doc/refman/en/charset-database.html
.. _PostgreSQL manual: https://www.postgresql.org/docs/current/static/multibyte.html
.. _Oracle manual: https://docs.oracle.com/database/121/NLSPG/toc.htm
.. _section 2: https://docs.oracle.com/database/121/NLSPG/ch2charset.htm#NLSPG002
.. _section 11: https://docs.oracle.com/database/121/NLSPG/ch11charsetmig.htm#NLSPG011


General string handling
=======================

In database lookups, template rendering, or anywhere else -- you can use strings.
If you have bytes, convert them to Unicode before passing it to Django.

.. warning::

    If you pass string to Django which contains invalid Unicode characters,
    things will go wrong in interesting ways. Usually, Django will raise a
    ``UnicodeDecodeError`` at some point.

Translated strings
------------------

Aside from strings and bytes, there's a third type of string-like object you may
encounter when using Django. The framework's internationalization features
introduce the concept of a "lazy translation" -- a string that has been marked
as translated but whose actual translation result isn't determined until the
object is used in a string. This feature is useful in cases where the
translation locale is unknown until the string is used, even though the string
might have originally been created when the code was first imported.

Normally, you won't have to worry about lazy translations. Just be aware that
if you examine an object and it claims to be a
``django.utils.functional.__proxy__`` object, it is a lazy translation.
Calling ``str()`` with the lazy translation as the argument will generate a
string in the current locale.

For more details about lazy translation objects, refer to the
:doc:`internationalization </topics/i18n/index>` documentation.

Useful utility functions
------------------------

Because some string operations come up again and again, Django ships with a few
useful functions that should make working with string and bytestring objects
a bit easier.

Conversion functions
~~~~~~~~~~~~~~~~~~~~

The ``django.utils.encoding`` module contains a few functions that are handy
for converting back and forth between strings and bytestrings.

* ``smart_text(s, encoding='utf-8', strings_only=False, errors='strict')``
  converts its input to a string. The ``encoding`` parameter
  specifies the input encoding. (For example, Django uses this internally
  when processing form input data, which might not be UTF-8 encoded.) The
  ``strings_only`` parameter, if set to True, will result in Python
  numbers, booleans and ``None`` not being converted to a string (they keep
  their original types). The ``errors`` parameter takes any of the values
  that are accepted by Python's ``str()`` function for its error
  handling.

* ``force_text(s, encoding='utf-8', strings_only=False,
  errors='strict')`` is identical to ``smart_text()`` in almost all
  cases. The difference is when the first argument is a :ref:`lazy
  translation <lazy-translations>` instance. While ``smart_text()``
  preserves lazy translations, ``force_text()`` forces those objects to a
  string (causing the translation to occur). Normally, you'll want
  to use ``smart_text()``. However, ``force_text()`` is useful in
  template tags and filters that absolutely *must* have a string to work
  with, not just something that can be converted to a string.

* ``smart_bytes(s, encoding='utf-8', strings_only=False, errors='strict')``
  is essentially the opposite of ``smart_text()``. It forces the first
  argument to a bytestring. The ``strings_only`` parameter has the same
  behavior as for ``smart_text()`` and ``force_text()``. This is
  slightly different semantics from Python's builtin ``str()`` function,
  but the difference is needed in a few places within Django's internals.

Normally, you'll only need to use ``force_text()``. Call it as early as
possible on any input data that might be either a string or a bytestring, and
from then on, you can treat the result as always being a string.

.. _uri-and-iri-handling:

URI and IRI handling
~~~~~~~~~~~~~~~~~~~~

Web frameworks have to deal with URLs (which are a type of IRI_). One
requirement of URLs is that they are encoded using only ASCII characters.
However, in an international environment, you might need to construct a
URL from an IRI_ -- very loosely speaking, a URI_ that can contain Unicode
characters. Quoting and converting an IRI to URI can be a little tricky, you
can use these functions.

* The function :func:`django.utils.encoding.iri_to_uri()` implements the
  conversion from IRI to URI as required by the specification (:rfc:`3987#section-3.1`).

* The functions :meth:`~urllib.parse.quote()` and :meth:`~urllib.parse.quote_plus()`
  from Python's standard library that work with Unicode characters.

These two groups of functions have slightly different purposes, and it's
important to keep them straight. Normally, you would use ``quote()`` on the
individual portions of the IRI or URI path so that any reserved characters
such as '&' or '%' are correctly encoded. Then, you apply ``iri_to_uri()`` to
the full IRI and it converts any non-ASCII characters to the correct encoded
values.

.. note::
    Technically, it isn't correct to say that ``iri_to_uri()`` implements the
    full algorithm in the IRI specification. It doesn't (yet) perform the
    international domain name encoding portion of the algorithm.

The ``iri_to_uri()`` function will not change ASCII characters that are
otherwise permitted in a URL. So, for example, the character '%' is not
further encoded when passed to ``iri_to_uri()``. This means you can pass a
full URL to this function and it will not mess up the query string or anything
like that.

An example might clarify things here::

    >>> quote('Paris & Orléans')
    'Paris%20%26%20Orl%C3%A9ans'
    >>> iri_to_uri('/favorites/François/%s' % quote('Paris & Orléans'))
    '/favorites/Fran%C3%A7ois/Paris%20%26%20Orl%C3%A9ans'

If you look carefully, you can see that the portion that was generated by
``quote()`` in the second example was not double-quoted when passed to
``iri_to_uri()``. This is a very important and useful feature. It means that
you can construct your IRI without worrying about whether it contains
non-ASCII characters and then, right at the end, call ``iri_to_uri()`` on the
result.

Similarly, Django provides :func:`django.utils.encoding.uri_to_iri()` which
implements the conversion from URI to IRI as per :rfc:`3987#section-3.2`.
It decodes all percent-encodings except those that don't represent a valid
UTF-8 sequence.

An example to demonstrate::

    >>> uri_to_iri('/%E2%99%A5%E2%99%A5/?utf8=%E2%9C%93')
    '/♥♥/?utf8=✓'
    >>> uri_to_iri('%A9helloworld')
    '%A9helloworld'

In the first example, the UTF-8 characters and reserved characters are
unquoted. In the second, the percent-encoding remains unchanged because it
lies outside the valid UTF-8 range.

Both ``iri_to_uri()`` and ``uri_to_iri()`` functions are idempotent, which means the
following is always true::

    iri_to_uri(iri_to_uri(some_string)) == iri_to_uri(some_string)
    uri_to_iri(uri_to_iri(some_string)) == uri_to_iri(some_string)

So you can safely call it multiple times on the same URI/IRI without risking
double-quoting problems.

.. _URI: https://www.ietf.org/rfc/rfc2396.txt
.. _IRI: https://www.ietf.org/rfc/rfc3987.txt

Models
======

Because all strings are returned from the database as ``str`` objects, model
fields that are character based (``CharField``, ``TextField``, ``URLField``,
etc.) will contain Unicode values when Django retrieves data from the database.

Taking care in ``get_absolute_url()``
-------------------------------------

URLs can only contain ASCII characters. If you're constructing a URL from
string, be careful to encode the results in a way that is suitable for a URL.
The :func:`~django.urls.reverse` function handles this for you automatically.

If you're constructing a URL manually (i.e., *not* using the ``reverse()``
function), you'll need to take care of the encoding yourself. In this case,
use the ``iri_to_uri()`` and ``quote()`` functions that were documented
above_. For example::

    from urllib.parse import quote

    from django.utils.encoding import iri_to_uri

    def get_absolute_url(self):
        url = '/person/%s/?x=0&y=0' % quote(self.location)
        return iri_to_uri(url)

This function returns a correctly encoded URL even if ``self.location`` is
something like "Jack visited Paris & Orléans". (In fact, the ``iri_to_uri()``
call isn't strictly necessary in the above example, because all the
non-ASCII characters would have been removed in quoting in the first line.)

.. _above: `URI and IRI handling`_

Templates
=========

You can use strings when creating templates manually::

    from django.template import Template
    t2 = Template('This is a string template.')

But the common case is to read templates from the filesystem, and this creates
a slight complication: not all filesystems store their data encoded as UTF-8.
If your template files are not stored with a UTF-8 encoding, set the :setting:`FILE_CHARSET`
setting to the encoding of the files on disk. When Django reads in a template
file, it will convert the data from this encoding to Unicode. (:setting:`FILE_CHARSET`
is set to ``'utf-8'`` by default.)

The :setting:`DEFAULT_CHARSET` setting controls the encoding of rendered templates.
This is set to UTF-8 by default.

Template tags and filters
-------------------------

A couple of tips to remember when writing your own template tags and filters:

* Always return strings from a template tag's ``render()`` method
  and from template filters.

* Use ``force_text()`` in preference to ``smart_text()`` in these
  places. Tag rendering and filter calls occur as the template is being
  rendered, so there is no advantage to postponing the conversion of lazy
  translation objects into strings. It's easier to work solely with
  strings at that point.

.. _unicode-files:

Files
=====

If you intend to allow users to upload files, you must ensure that the
environment used to run Django is configured to work with non-ASCII file names.
If your environment isn't configured correctly, you'll encounter
``UnicodeEncodeError`` exceptions when saving files with file names that
contain non-ASCII characters.

Filesystem support for UTF-8 file names varies and might depend on the
environment. Check your current configuration in an interactive Python shell by
running::

    import sys
    sys.getfilesystemencoding()

This should output "UTF-8".

The ``LANG`` environment variable is responsible for setting the expected
encoding on Unix platforms. Consult the documentation for your operating system
and application server for the appropriate syntax and location to set this
variable.

In your development environment, you might need to add a setting to your
``~.bashrc`` analogous to:::

    export LANG="en_US.UTF-8"

Email
=====

Django's email framework (in ``django.core.mail``) supports Unicode
transparently. You can use Unicode data in the message bodies and any headers.
However, you're still obligated to respect the requirements of the email
specifications, so, for example, email addresses should use only ASCII
characters.

The following code example demonstrates that everything can be string
except email addresses which should use only ASCII characters::

    from django.core.mail import EmailMessage

    subject = 'My visit to Sør-Trøndelag'
    sender = 'Arnbjörg Ráðormsdóttir <arnbjorg@example.com>'
    recipients = ['Fred <fred@example.com']
    body = '...'
    msg = EmailMessage(subject, body, sender, recipients)
    msg.attach("Une pièce jointe.pdf", "%PDF-1.4.%...", mimetype="application/pdf")
    msg.send()

Form submission
===============

HTML form submission is a tricky area. There's no guarantee that the
submission will include encoding information, which means the framework might
have to guess at the encoding of submitted data.

Django adopts a "lazy" approach to decoding form data. The data in an
``HttpRequest`` object is only decoded when you access it. In fact, most of
the data is not decoded at all. Only the ``HttpRequest.GET`` and
``HttpRequest.POST`` data structures have any decoding applied to them. Those
two fields will return their members as Unicode data. All other attributes and
methods of ``HttpRequest`` return data exactly as it was submitted by the
client.

By default, the :setting:`DEFAULT_CHARSET` setting is used as the assumed encoding
for form data. If you need to change this for a particular form, you can set
the ``encoding`` attribute on an ``HttpRequest`` instance. For example::

    def some_view(request):
        # We know that the data must be encoded as KOI8-R (for some reason).
        request.encoding = 'koi8-r'
        ...

You can even change the encoding after having accessed ``request.GET`` or
``request.POST``, and all subsequent accesses will use the new encoding.

Most developers won't need to worry about changing form encoding, but this is
a useful feature for applications that talk to legacy systems whose encoding
you cannot control.

Django does not decode the data of file uploads, because that data is normally
treated as collections of bytes, rather than strings. Any automatic decoding
there would alter the meaning of the stream of bytes.
