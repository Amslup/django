===================
Model ``_meta`` API
===================

.. module:: django.db.models.options
   :synopsis: Model meta-class layer

.. class:: Options

The Model ``_meta`` API is at the core of Django. It enables other parts of the
system such as lookups, queries, forms, and the admin to understand the
capabilities of each model. The API is accessible through the ``_meta``
attribute of each model class. It's a ``django.db.models.options.Options``
object.

Methods that it provides can be used for:

* Retrieving all field names of a model
* Retrieving all field instances names of a model
* Retrieving a single field by name

.. _model-meta-field-types:

Field Types
===========

Fields are in 2 main categories:

Forward fields
~~~~~~~~~~~~~~

A forward field in any field that is defined on the current model. A forward
field can also have relationships with 1 or many models. There are plenty of
forward field examples as they are by far the most used field type, such as
``CharField``, ``BooleanField``, or ``ForeignKey``.

Reverse fields
~~~~~~~~~~~~~~

A reverse field is a field defined on another model that points to the current
model. Although these objects are treaded just like other fields, they are
usually links to fields, such as a ``RelatedObject``. Reverse fields are
usually constructed transparently to the user, but can sometimes be explicitly
defined on a model, such as a ``GenericForeignKey``.

.. code-block:: python

    class City(models.Model):
        name = models.CharField(max_length=100)

    class Person(models.Model):
        city = models.ForeignKey(City)

In this case, ``City`` has a reverse field from ``Person``.

.. _model-meta-field-apis:

``Field-access APIs``
=====================

Retrieving a field instance by name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. method:: Options.get_field(field_name)

    Returns the field instance given a name of a field.

    ``field_name`` can be the name of a forward or reverse field on the
    current model.
    Hidden reverse fields are not available, because by definition they
    should not be looked up.
    If a field with the given name is not found a ``FieldDoesNotExist``
    exception will be raised.

    .. code-block:: python

        >>> from django.contrib.auth.models import User

        >>> User._meta.get_field('username')#  A forward field
        <django.db.models.fields.CharField: username>

        >>> User._meta.get_field('logentry')#  A reverse field
        <RelatedObject: admin:logentry related to user>

        >>> LogEntry._meta.get_field('user')#  ForeignKey can be queried by field name
        <django.db.models.fields.related.ForeignKey: user>
        >>> LogEntry._meta.get_field('user_id')#  .. and also by database column name
        <django.db.models.fields.related.ForeignKey: user>

        >>> User._meta.get_field('does_not_exist')#  A non existent field
        Traceback (most recent call last):
            ...
        FieldDoesNotExist: User has no field named 'does_not_exist'

    .. versionchanged:: 1.8

        :meth:`Options.get_field()` does not accept a ``many_to_many``
        flag any more. This method will automatically search through both
        forward and reverse fields, with no way to exclude M2M fields.
        If you wish to filter out M2M fields, you can do further filtering
        using the :ref:`field attributes <field-attributes>`.

Retrieving all field names
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. attribute:: Options.field_names

    .. versionadded:: 1.8

    Returns a list of all forward and reverse field names on the
    current model.

    .. note::
        For performance reasons, the return type of ``field_names``
        is an ImmutableList and therefore cannot be mutated. If there
        is a need to manipulate the list consider making a copy.

    .. code-block:: python

        >>> User._meta.field_names
        ['username', 'first_name', 'last_name', 'logentry',
         'is_active', 'email', 'is_superuser', 'is_staff',
         'last_login', 'groups', 'user_permissions', 'password',
         'id', 'date_joined']

Retrieving field instances
~~~~~~~~~~~~~~~~~~~~~~~~~~

In addition to the general API for accessing the fields on a model, Django also
provides a set of properties that caches commonly needed subsets of fields.
You should prefer to use the properties for better readability and performance,
however, if there isn't an appropriate property that contains the fields you
need, you can use the ``get_fields()`` method along with its filtering flags.

.. attribute:: Options.fields

    Returns a list of all data fields.

.. attribute:: Options.concrete_fields

    Returns a list of all concrete data fields.

.. attribute:: Options.local_concrete_fields

    Returns a list of all concrete data fields that have not been inherited
    from another model.

.. attribute:: Options.many_to_many

    Returns a list of all many-to-many fields.

.. method:: Options.get_fields(forward=True, reverse=False, include_parents=True, include_hidden=False)

    .. versionadded:: 1.8

    Returns a list of fields given a list of field types and filters.

    ``get_fields()`` takes a set of flags as parameters and returns a tuple of
    field instances. The flags are a combination of field types and field
    filters. All possible combinations of filters and fields are possible,
    although some will have no effect (such as ``include_hidden`` combined with
    ``forward``).

    Available parameters are:

    ``forward``
        Searches through forward fields.

    ``reverse``
        Searches through forward fields.

    ``include_parents``
        Searches recursively through all parents, if disabled it will only search for 
        fields declared directly on the current model.
        Fields from models that directly inherit from abstract models or
        proxy classes are still local.

    ``include_hidden``
        Hidden fields are a subset of reverse fields, and will not have any effect on
        forward field queries. When a field that contains 1 or more relations (such as
        :class:`django.db.models.ManyToManyField`, or
        :class:`django.db.models.ForeignKey`) specifies a ``related_name`` that starts
        with a "+", it tells Django to exclude the relation as public, and therefore it
        becomes a hidden field.

    .. code-block:: python

        >>> User._meta.get_fields() # Only data by default
        (<django.db.models.fields.AutoField: id>,
         <django.db.models.fields.CharField: password>,
         <django.db.models.fields.DateTimeField: last_login>,
         <django.db.models.fields.BooleanField: is_superuser>,
         <django.db.models.fields.CharField: username>,
         <django.db.models.fields.CharField: first_name>,
         <django.db.models.fields.CharField: last_name>,
         <django.db.models.fields.EmailField: email>,
         <django.db.models.fields.BooleanField: is_staff>,
         <django.db.models.fields.BooleanField: is_active>,
         <django.db.models.fields.DateTimeField: date_joined>)

        >>> User._meta.get_fields(forward=False, reverse=True) # only related_objects
        (<RelatedObject: admin:logentry related to user>,)

        >>> User._meta.get_fields(forward=False, reverse=True, include_hidden=True) # only include hidden forward fields.
        (<RelatedObject: auth:user_groups related to user>,
         <RelatedObject: auth:user_user_permissions related to user>,
         <RelatedObject: admin:logentry related to user>)
