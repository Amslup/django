==================
Checking framework
==================

Checking framework is a set of static checks validating mainly apps and
models. It detects common problems and report them providing hints.

Checking can be triggered explicitly via ``python manage.py check`` command.
It's also triggered implicitly before most command, including ``runserver``
and ``syncdb``. For performance issues, the checks are not performed if
``DEBUG`` is set to False.

Checking framework is really flexible and allow you to write functions (or
other callable objects like methods) performing any kind of checks. The
function has to receive ``**kwargs`` and return list of errors and warnings.
If there are no errors, you still have to return an empty list. In case of
fields and managers, you can just override ``check`` method. There is relevant
classmethod for models. In other cases, you need to `register the function`_.

.. _`register the function`: `registering-checks`_

Errors and warnings
===================

.. class:: Error(msg, hint, obj=None)
.. class:: Warning(msg, hint, obj=None)

``django.core.checks`` defines two classes: ``Error`` and ``Warning``. Both
have the same interface, they differ only in their meaning. When an Error
occures, Django stops everything and doesn't allow to i. e. run a server.
Warnings are reported along with Errors, but you can run server even though
there are Warnings.

Constructor arguments are:

``msg``
    A required string. It can consists of one or more lines. In the latter
    case, the first line is a short description and the rest is a long
    description.

``hint``
    A single-line string or ``None`` if you cannot provide any hint. Note that
    this argument is required even if you pass ``None``::

        Error('error message') # bad
        Error('error message', hint=None) # good

``obj``
    Optional. Point to the invalid object.

Errors and Warnings are comparable. That allows you to easily write tests::

    from django.core.checks import Error
    errors = checked_object.check()
    expected_errors = [Error('an error', hint=None, obj=checked_object)]
    self.assertEqual(errors, expected_errors)

.. _field-checking:

Field checking
==============

If you created your own field, you may want to add some checking. In that
case, you need to override `check` method: it should call the superclass (1),
perform its own checks which may end in new errors or warnings (2) and
eventually return list of all errors and warnings (3). It's recommended to
delegate checks to separated methods whose names start with ``_check_``, i. e.
``_check_min_max_values``.

Consider an example where you are implementing ``RangedIntegerField``. It adds
``min`` and ``max`` arguments to the constructor. You want to check if min
value is smaller or equal to max value. Here is a snippet of code showing how
you can implement this check::

    from django.core import checks
    from django.db import models

    class RangedIntegerField(models.IntegerField):
        def __init__(self, min=None, max=None, **kwargs):
            super(RangedIntegerField, self).__init__(**kwargs)
            self.min = min
            self.max = max

        def check(self, **kwargs):
            errors = super(MyField, self).check(**kwargs) # (1) call the superclass
            # (2) Do some custom checking and add errors and warning to `errors`:
            errors.extend(self._check_min_max_values(**kwargs))
            return errors # (3) return all errors and warnings

        def _check_min_max_values(self, **kwargs):
            if (self.min is not None and
                self.max is not None and
                self.min > self.max):
                return [checks.Error('min greated than max.',
                    hint='Lower min or upper max.',
                    obj=self)]
            return [] # When no error, return an empty list

Database backend specific checks are performed in
``DatabaseValidation.check_field`` method. The API of ``DatabaseValidation``
is not formally stable and may change in future.

Manager checking
================

Manager checking is very similar to :ref:`field checking <field-checking>`.
The only difference is that your class needs to inherit from
``models.Manager``.

Model checking
==============

It's possible to check Model classes. Note that the framework verifies the
class, not it's instances. It works exactly the same as field checking except
you need to use classmethods::

    class MyModel(models.Model):
        @classmethod
        def check(cls, **kwargs):
            errors = super(MyModel, cls).check(**kwargs)
            # ... your own checking stuff ...
            return errors

.. _`registering-checks`:

Registering checks
==================

You may be interested in app-specific checks or other kinds of checks which
are connected with neither fields, managers nor models. In that case, you need
to write a function (or other kind of callable object) performing the checks
and register it.

.. method:: register(callable)

The callable has to follow the contract defined at the beginning of this doc
-- it receives ``**kwargs`` and returns list of errors and warnings.

Note that checks are performed just after loading apps and you need to
register them earlier. It's recommended to call the ``register`` function at
the module level so the checks will be registered at the the time of importing
the module.